from random import randint  

# x - нижняя граница, y - верхняя граница, s - середина

def binary_search(arr, x, y, znach):      #Функция бинарного поиска для нахождения индекса элемента в отсортированном массиве
    s = -1  
    while x <= y:                         # Пока границы поиска не пересеклись
        s = x + (y - x) // 2              # Находим середину
        if arr[s] == znach:               # Если элемент найден
            return s                      # Возвращаем индекс
        elif arr[s] > znach:              # Если элемент в середине больше искомого
            x = s + 1                     # Ищем в правой половине
        else:                             # Если элемент в середине меньше искомого
            y = s - 1                     # Ищем в левой половине
    return s                              # Возвращаем индекс, где можно вставить новый элемент

def sort(massiv, i, l, r):                # Функция быстрой сортировки для сортировки массива и соответствующих индексов
    if r - l > 1:                         # Проверяем, есть ли элементы для сортировки
        i_pivot = randint(l, r)           # Случайный выбор опорного элемента
        pivot = massiv[i_pivot]           # Опорный элемент
        massiv[r], massiv[i_pivot] = massiv[i_pivot], massiv[r]  # Перемещаем опорный элемент в конец
        index[r], index[i_pivot] = index[i_pivot], index[r]
        i_pivot = r                       # Обновляем индекс опорного элемента
        r = r - 1                         # Уменьшаем правую границу

        while r - l != -1:                # Пока границы не пересеклись
                                          # Находим элемент больше или равный опорному слева
            while massiv[l] >= pivot and r - l != -1:
                l += 1
                                          # Находим элемент меньше или равный опорному справа
            while massiv[r] <= pivot and r - l != -1:
                r -= 1
            
            if r < l:                     # Если нашли элементы, которые нужно поменять местами
                massiv[i_pivot], massiv[l] = massiv[l], massiv[i_pivot]
                i[i_pivot], i[l] = i[l], i[i_pivot]
            else:                         # Меняем местами элементы слева и справа
                massiv[l], massiv[r] = massiv[r], massiv[l]
                i[l], i[r] = i[r], i[l]

                                          # Рекурсивно сортируем левую и правую части массива
        sort(massiv, i, 0, r)
        sort(massiv, i, l, i_pivot)
    return (massiv, i)                    # Возвращаем отсортированные массивы

##### ИСПОЛЬЗОВАНИЕ #####
n = int(input('Введите количество параметров ранжирования: '))  
a = list(map(int, input('Введите ' + str(n) + ' целых чисел').split(' '))) 
d = int(input('Введите количество объектов для ранжирования: '))  

f = []                                     # Список для хранения признаков объектов
relevance_znach = []                       # Список для хранения релевантности объектов
relevance_i = []                           # Список для хранения индексов объектов

for i in range(d):                         # Для каждого объекта
    f.append(list(map(int, input('Введите ' + str(n) + ' целых чисел через пробел: ').split(' '))))  # Ввод признаков объекта
    relevance_data.append(0)               # Инициализируем релевантность нулем
    
    for j in range(n):                      # Для каждого параметра
        relevance_data[i] += a[j] * f[i][j]  # Вычисляем релевантность как скалярное произведение весов и признаков
    
    relevance_i.append(i + 1)                # Индекс объекта (начиная с 1)

relevance_znach, relevance_i = quick_sort(relevance_znach, relevance_i, 0, len(relevance_znach) - 1)  
                                            # Сортируем объекты по релевантности

q_n = int(input('Введите количество запросов к системе ранжирования: '))  # Количество запросов

for i in range(q_n):                       # Для каждого запроса
    q = list(map(int, input('Введите запрос состоящий из целых чисел через пробел: ').split(' ')))
    if q[0] == 1:                          # Запрос на получение k самых релевантных документов
      print(q[1], 'самых релевантных документов:', end=' ')
      for j in range(q[1]):                # Печатаем индексы k самых релевантных документов
        print(relevance_i[j], end=' ')
      print()
    
    elif q[0] == 2:                       # Запрос на обновление значения признака объекта
        rel_i = relevance_i.i(q[1])       # Находим индекс объекта в списке (0-индексация)
        new_rel = relevance_znach[rel_i] - (a[q[2] - 1] * f[q[1] - 1][q[2] - 1]) + (a[q[2] - 1] * q[3])  
                                          # Вычисляем новую релевантность
        
        relevance_znach.pop(rel_i)        # Удаляем старую релевантность
        relevance_i.pop(rel_i)            # Удаляем индекс объекта
        
        f[q[1] - 1][q[2] - 1] = q[3]      # Обновляем значение признака
        
        s = binary_search(relevance_znach, 0, len(relevance_znach) - 1, new_rel)  
                                          # Находим место для новой релевантности с помощью бинарного поиска
        
        relevance_data.insert(s, new_rel)  # Вставляем новую релевантность
        relevance_index.insert(s, q[1])    # Вставляем индекс объекта

